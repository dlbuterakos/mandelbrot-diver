import java.awt.*;
import java.awt.event.*;
import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import javax.swing.*;

/**
 * Mandelbrot Diver is program that generates images of the Mandelbrot Set.
 * It has an intuitive GUI that allows the user to click and drag to zoom in, 
 * or copy-paste zoom coordinates from other sources.
 * The program stores the past several images generated, and allows the user to
 * undo and go back earlier images up to a point.
 * It allows the user to define their own gradient color scheme,
 * and comes with several preset gradients and zoom locations.
 * <p>
 * {@code MandelbrotDiver} is the entry point to the program.
 * A single instance of the frame is created and shown.
 * <p>
 * {@code MandelbrotDiver extends JFrame} contains the GUI components and handles events.
 * It contains a {@link StateStack} instance which is responsible for storing the current state of the program.
 * This includes zoom parameters, image and gradient options, and the escape-time output from which the current displayed image is derived.
 * The {@code StateStack} also keeps a record of past changes and is responsible for handling undo / redo requests.
 * <p>
 * Subclasses of the abstract class {@link FractalModel} are responsible for generating the image.
 * One subclass, {@link MandelbrotModel}, is provided for generating images of the Mandelbrot set.
 * Other fractals such as the Burning Ship fractal can be generated by extending the {@code FractalModel} class
 * and implementing the {@link FractalModel#escapeTime()} method.
 * <p>
 * The GUI consists of a {@link JTabbedPane} on the left side which allows the user to set the options for image generation.
 * Under the tabbed pane are Undo, Redo, and Run buttons.
 * Finally, on the right side is an {@link ImagePanel} which displays the output image.
 * <p>
 * Mandelbrot Diver allows the user to click and drag to set the zoom parameters.
 * The {@code MandelbrotDiver} class handles this functionality
 * and draws the bounding rectangle over top of the {@code ImagePanel} that displays the image.
 * 
 * @author Donovan Buterakos
 */
@SuppressWarnings("serial")
public class MandelbrotDiver extends JFrame {
	
	/**
	 * The entry point to the program. Instantiates and shows a {@code MandelbrotDiver} frame.
	 * @param args Command line parameters are ignored.
	 */
    public static void main(String[] args) {
    	EventQueue.invokeLater(new Runnable() {
            @Override public void run() {
            	MandelbrotDiver mandelbrotDiver = new MandelbrotDiver();
            	mandelbrotDiver.setVisible(true);
            }
    	});
    }
    
    // ------------------------ Constants ---------------------------

    /**
     * {@link MathContext} object specifying the rounding behavior for converting the zoom width (stored as a double) to a {@link BigDecimal}.
     */
    private static final MathContext WIDTH_CONTEXT = new MathContext(16, RoundingMode.HALF_EVEN);
    
    /**
     * Pixels are generally desired to be colored roughly according to the fractional part of the natural log of their escape time.
     * However, this means for escape times close to 0, colors would vary drastically.
     * To fix this, a small offset is added, and pixels are colored according to the fractional part of {@code Math.log(escapeTime + LOG_OFFSET)}.
     */
    private static final double LOG_OFFSET = 10.;
    
    /**
     * The number of increments for adjusting the x-position spinner to move across the width of the image.
     */
    private static final double NUM_INCREMENTS = 40;
    
    /**
     * {@link MathContext} object specifying the rounding behavior for increments of {@link BigDecimal} spinners.
     */
    private static final MathContext INCREMENT_CONTEXT = new MathContext(3, RoundingMode.HALF_EVEN);
    
    // Various constants used in GUI
	private static final String FRAME_TITLE = "Mandelbrot Diver";
	private static final int INITIAL_FRAME_WIDTH = 755;
	private static final int INITIAL_FRAME_HEIGHT = 465;
	private static final String TAB_TITLE_ZOOM = "Zoom";
    private static final String TAB_TITLE_COLORS = "Colors";
    private static final String TAB_TITLE_PRESET = "Presets";
    private static final int MARGIN_BUTTONS = 4;
    private static int MIN_SPINNER_SIZE = 30;
    private static final int OPTION_PANEL_SIZE = 250;
    
	// Strings for tooltips of various components
    private static final String TOOLTIP_POSITION_X = "x-coordinate of center";
    private static final String TOOLTIP_POSITION_Y = "y-coordinate of center";
    private static final String TOOLTIP_ZOOM_WIDTH = "Zoom level";
    private static final String TOOLTIP_MAX_ITERATIONS = "Maximum number of iterations";
    private static final String TOOLTIP_IMAGE_WIDTH = "Image width (pixels)";
    private static final String TOOLTIP_IMAGE_HEIGHT = "Image height (pixels)";
    private static final String TOOLTIP_SAMPLE_POINTS = "Number of sample points per pixel";
    private static final String TOOLTIP_UNDO = "Undo";
    private static final String TOOLTIP_REDO = "Redo";
    private static final String TOOLTIP_RUN = "Generate image";
    private static final String TOOLTIP_FRACTAL_COLOR = "Color of the fractal";
    private static final String TOOLTIP_RECT_COLOR = "Color of selected area";
    private static final String TOOLTIP_OFFSET = "Gradient starting color";
    private static final String TOOLTIP_GRAD_SPACING = "Spacing of gradient bands";
    private static final String TOOLTIP_IMAGE_PANEL = "Click and drag to zoom";
    
    // ------------------------ Presets ---------------------------
    /**
     * {@link ZoomPreset} used to place the String "Choose" in {@code comboZoom} to handle custom zoom settings.
     */
	private static final ZoomPreset CHOOSE_ZOOM = new ZoomPreset("Choose", BigDecimal.ZERO, BigDecimal.ZERO, 4., 1, 1.);
	/**
	 * Initial zoom settings showing the full Mandelbrot set.
	 */
	private static final ZoomPreset FULL_MAND = new ZoomPreset("Initial View", BigDecimal.ZERO, BigDecimal.ZERO, 4., 1000, 1.);
	/**
	 * A collection of interesting zoom locations used for presets.
	 */
	private static final ZoomPreset[] zoomPresets = new ZoomPreset[] {
		CHOOSE_ZOOM,
		FULL_MAND,
		new ZoomPreset("Elephant Dreams", new BigDecimal("0.2769164"), new BigDecimal("-0.00728924"), 1.28e-6, 10000, 1.5),
		new ZoomPreset("Seahorse Haven", new BigDecimal("-0.74495233315018782681"), new BigDecimal("-0.16564621433806031123"), 8.0e-12, 5000, 0.8),
		new ZoomPreset("Serpents Kiss", new BigDecimal("-1.2916166849664920615"), new BigDecimal("0.0676892743567269805"), 4.1e-6, 5000, 0.8),
		new ZoomPreset("Lightning", new BigDecimal("-0.163368695121214"), new BigDecimal("1.0261789559174069"), 8.0e-8, 1000, 1.0),
		new ZoomPreset("Sunburst", new BigDecimal("-1.999943523313687854072266506278"), new BigDecimal("1.201448411021895957495E-10"), 1.0e-20, 2000, 0.5),
		new ZoomPreset("Galaxy", new BigDecimal("-0.245074090003808"), new BigDecimal("0.71712167773103"), 2.5e-8, 10000, 0.9)
	};
	
	/**
     * {@link ColorPreset} used to place the String "Choose" in {@code comboColor} to handle custom color settings.
     */
	private static final ColorPreset CHOOSE_COLOR = new ColorPreset("Choose", Color.black, Color.black, new Gradient(new Color[] {Color.white}, new double[] {1.}));
	/**
	 * Initial color scheme.
	 */
	private static final ColorPreset INITIAL_PRESET = new ColorPreset("Purple Splash", Color.black, Color.red, new Gradient(new Color[] {
			new Color(0x08, 0x08, 0xC0), new Color(0x6C, 0x08, 0xC0),
			new Color(0xD0, 0x08, 0xF8), new Color(0xF0, 0x7C, 0xF8),
			new Color(0xF0, 0xF0, 0xF8), new Color(0x7C, 0xD0, 0xF8),
			new Color(0x08, 0xD0, 0xF8), new Color(0x08, 0x6C, 0xF8)}, 
			new double[] {.9, 1., 1.2, 1.1, 1.1, 1., .9, 1.}));
	/**
	 * A collection of nice color schemes used for presets.
	 */
	private static final ColorPreset[] colorPresets = new ColorPreset[] {
			CHOOSE_COLOR,
			INITIAL_PRESET,
			new ColorPreset("Sunset", Color.black, new Color(0x00, 0xD0, 0x00), new Gradient(new Color[] { 
					new Color(0x90, 0xB0, 0xF8), new Color(0x10, 0x60, 0xF0), new Color(0x08, 0x08, 0x90), new Color(0x50, 0x10, 0x50),
					new Color(0xB0, 0x08, 0x08), new Color(0xF8, 0x80, 0x08), new Color(0xF8, 0xF0, 0x50), new Color(0xF8, 0xF8, 0xF0)}, 
					new double[] {.9, .9, .7, .9, .9, 1., 1.1, .8})),
			new ColorPreset("Savannah", Color.black, Color.blue, new Gradient(new Color[] {
					new Color(0x80, 0x80, 0x08), new Color(0xA0, 0x40, 0x08), new Color(0xF8, 0x80, 0x10), new Color(0xF8, 0xA0, 0x30), new Color(0xE8, 0xE8, 0x08),
					new Color(0xA0, 0xF8, 0x30),  new Color(0x50, 0xF8, 0x08), new Color(0x08, 0xD0, 0x08), new Color(0x08, 0xA0, 0x08)},
					new double[] {.8, 1.2, .6, .9, .9, .9, 1., .6, 1.4})),
			new ColorPreset("Ocean", Color.black, Color.red, new Gradient(new Color[] {
					new Color(0x20, 0x08, 0xB0), new Color(0x08, 0x20, 0xD0), new Color(0x08, 0xD0, 0xE0), new Color(0x20, 0xF0, 0x40), new Color(0x60, 0xF8, 0x80),
					new Color(0xF0, 0xF8, 0xF8), new Color(0x40, 0x80, 0xF8), new Color(0x10, 0x08, 0xF8)},
					new double[] {.3, 1.1, .9, .5, .9, 1.1, .8, .4})),
			new ColorPreset("Embers", Color.black, Color.blue, new Gradient(new Color[] { 
					new Color(0x60, 0x60, 0x70), new Color(0x60, 0x08, 0x08), new Color(0xF8, 0x08, 0x08), new Color(0xF8, 0xF8, 0x08), new Color(0xF4, 0xF4, 0xF8)}, 
					new double[] {1., .5, 1.2, 1., 1.}))
	};
	
    // ------------------------ Instance Fields ---------------------------
	
    /**
     * {@link StateStack} object that tracks the current state of the program, 
     * including zoom parameters, image and gradient options, and the escape-time output from which the current displayed image is derived.
     * The {@code StateStack} also keeps a record of past changes and is responsible for handling undo / redo requests.
     */
    private StateStack ss = new StateStack(defaultOptions());
    
    private ValueSpinnerFactory.DynamicIncrementable incrementable = new ValueSpinnerFactory.DynamicIncrementable() {
    	@Override public BigDecimal increment() {
			return new BigDecimal(ss.lastRunOptions().getZoomWidth() / NUM_INCREMENTS, INCREMENT_CONTEXT);
		}
    };
    
    /**
     * x-coordinate of the pixel where the user pressed down the mouse when drawing the rectangle for zoom bounds
     */
 	private int rectStartX;
 	/**
     * y-coordinate of the pixel where the user pressed down the mouse when drawing the rectangle for zoom bounds
     */
 	private int rectStartY;
    
    // GUI components:
 	// Main Form Components
 	private ImagePanel imagePanel = new ImagePanel();
 	private JTabbedPane tabbedPaneOptions = new JTabbedPane();
 	private JButton buttonRun = new JButton("Run!");
 	private RectangleDecorator<JPanel> rectDecorator = new RectangleDecorator<JPanel>();
 	private JLayer<JPanel> imageLayer = new JLayer<JPanel>(imagePanel, rectDecorator);
 	private JButton buttonUndo = new JButton("\u21B6");
	private JButton buttonRedo = new JButton("\u21B7");
 	// Zoom Options Components
 	private JScrollPane scrollOptionsZoom = new JScrollPane();
 	private ScrollablePanel panelOptionsZoom = new ScrollablePanel();
 	private JLabel labelPosition = new JLabel("Coordinates");
 	private ValueSpinner<BigDecimal> spinnerPositionX = ValueSpinnerFactory.createBigDecimalSpinner(incrementable);
	private ValueSpinner<BigDecimal> spinnerPositionY = ValueSpinnerFactory.createBigDecimalSpinner(incrementable);
	private JLabel labelPositionX = new JLabel("X:");
	private JLabel labelPositionY = new JLabel("Y:");
	private JLabel labelZoom = new JLabel("Zoom Level");
	private ValueSpinner<Double> spinnerZoomWidth = ValueSpinnerFactory.createScalingDoubleSpinner();
	private JLabel labelZoomWidth = new JLabel("Width:");
	private ValueSpinner<Long> spinnerMaxIterations = ValueSpinnerFactory.createScalingLongSpinner();
	private JLabel labelMaxIterations = new JLabel("Max Iterations:");
	private JLabel labelImageSize = new JLabel("Image Size");
	private ValueSpinner<Integer> spinnerImageWidth = ValueSpinnerFactory.createBoundedIntegerSpinner(400, 1, 10000, 10);
	private ValueSpinner<Integer> spinnerImageHeight = ValueSpinnerFactory.createBoundedIntegerSpinner(400, 1, 10000, 10);
	private JLabel labelImageWidth = new JLabel("Width:");
	private JLabel labelImageHeight = new JLabel("Height:");
	private JLabel labelSamplePoints = new JLabel("Points per Pixel:");
	private ValueSpinner<Double> spinnerSamplePoints = ValueSpinnerFactory.createBoundedDoubleSpinner(1., 1., 100., 1.);
 	// Color Options Components
 	private JScrollPane scrollOptionsColors = new JScrollPane();
 	private ScrollablePanel panelOptionsColors = new ScrollablePanel();
 	private JLabel labelColorFractal = new JLabel("Fractal Color:");
	private ColorButton colorButtonFractal = new ColorButton(Color.black, "Choose Mandelbrot Set Color", "Choose");
	private JLabel labelColorRect = new JLabel("Zoom Outline:"); 
	private ColorButton colorButtonRect = new ColorButton(Color.red, "Choose Zoom Area Color", "Choose");
	private JLabel labelGradient = new JLabel("Gradient Colors");
	private GradientChooser gradientChooser = new GradientChooser(MARGIN_BUTTONS);
	private ContinuousSlider sliderOffset = new ContinuousSlider();
	private GradientPanel gradientPanel = new GradientPanel(ss.currentOptions().getGradient());
	private JLabel labelOffset = new JLabel("Gradient Offset");
	private JLabel labelGradientScale = new JLabel("Gradient Scale:");
	private ValueSpinner<Double> spinnerGradientScale = ValueSpinnerFactory.createScalingDoubleSpinner();
 	// Preset Components
 	private JScrollPane scrollOptionsPreset = new JScrollPane();
 	private ScrollablePanel panelOptionsPreset = new ScrollablePanel();
	private JLabel labelPresetZoom = new JLabel("Zoom Presets");
	private JLabel labelPresetColor = new JLabel("Color Presets");
	private JComboBox<ZoomPreset> comboZoom = new JComboBox<ZoomPreset>(MandelbrotDiver.zoomPresets);
	private JComboBox<ColorPreset> comboColor = new JComboBox<ColorPreset>(MandelbrotDiver.colorPresets);

	// ------------------------ Constructor & Initialization Methods ---------------------------
	
	/**
	 * Creates a new, initially invisible frame.
	 */
	public MandelbrotDiver() {
		super(FRAME_TITLE);
		setSize(INITIAL_FRAME_WIDTH, INITIAL_FRAME_HEIGHT); 
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        initializeGUI();
        initializeValues();
        initializeListeners();
        generate();
   	}
	
	/**
	 * Called by the constructor to initialize GUI components.
	 * <p>
	 * The GUI consists of a {@link JTabbedPane} on the left side which allows the user to set the options for image generation.
	 * Under the Tabbed Pane are Undo, Redo, and Run buttons.
	 * On the right side is an {@link ImagePanel} which displays the output image.
	 * <p>
	 * The Tabbed Pane has 3 tabs: <ul>
	 * <li>The Zoom tab allows the user to adjust the coordinates, zoom-level, number of iterations to run,
	 * image size, and number of sample points per image.</li>
	 * <li>The Color tab allows the user to choose the gradient colors and fractal color used for generating the image,
	 * as well as the color of the rectangle drawn when the user is drawing the zoom bounds.
	 * It also allows the user to adjust the gradient offset (starting color), and color spacing (how long before the gradient repeats).</li>
	 * <li>The Preset tab contains several nice zoom locations for the Mandelbrot set, as well as several gradient color schemes.</li>
	 * </ul>
	 */
	private void initializeGUI() {
		
		// ========== Form Layout ==========
		
		GroupLayout formLayout = new GroupLayout(getContentPane());
		this.setLayout(formLayout);
		
		formLayout.setHorizontalGroup(formLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(formLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
				.addComponent(tabbedPaneOptions, OPTION_PANEL_SIZE, OPTION_PANEL_SIZE, OPTION_PANEL_SIZE)
				.addGroup(formLayout.createSequentialGroup()
					.addComponent(buttonUndo)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(buttonRedo)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(buttonRun)
				)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(imageLayer)
			.addContainerGap()
		);
		
		formLayout.setVerticalGroup(formLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(formLayout.createParallelGroup()
				.addGroup(formLayout.createSequentialGroup()
					.addComponent(tabbedPaneOptions)
					.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
					.addGroup(formLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
						.addComponent(buttonUndo)
						.addComponent(buttonRedo)
						.addComponent(buttonRun)
					)
				)
				.addComponent(imageLayer)
			)
			.addContainerGap()
		);
		
		getContentPane().setFocusable(true);
		
		imagePanel.setToolTipText(TOOLTIP_IMAGE_PANEL);
		buttonUndo.setToolTipText(TOOLTIP_UNDO);
		buttonRedo.setToolTipText(TOOLTIP_REDO);
		buttonRun.setToolTipText(TOOLTIP_RUN);
		
		// ========== Zoom Options Layout ==========
		
		tabbedPaneOptions.addTab(TAB_TITLE_ZOOM, scrollOptionsZoom);
		scrollOptionsZoom.setViewportView(panelOptionsZoom);
		GroupLayout zoomLayout = new GroupLayout(panelOptionsZoom);
		panelOptionsZoom.setLayout(zoomLayout);
		
		zoomLayout.setVerticalGroup(zoomLayout.createSequentialGroup()
			.addContainerGap()
			.addComponent(labelPosition)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelPositionX)
				.addComponent(spinnerPositionX)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelPositionY)
				.addComponent(spinnerPositionY)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(labelZoom)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelZoomWidth)
				.addComponent(spinnerZoomWidth)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelMaxIterations)
				.addComponent(spinnerMaxIterations)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(labelImageSize)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelImageWidth)
				.addComponent(spinnerImageWidth)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelImageHeight)
				.addComponent(spinnerImageHeight)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelSamplePoints)
				.addComponent(spinnerSamplePoints)
			)
			.addContainerGap()
		);
		
		zoomLayout.setHorizontalGroup(zoomLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(zoomLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
				.addComponent(labelPosition)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelPositionX)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerPositionX, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelPositionY)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerPositionY, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addComponent(labelZoom)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelZoomWidth)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerZoomWidth, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelMaxIterations)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerMaxIterations, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addComponent(labelImageSize)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelImageWidth)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerImageWidth, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addGroup(zoomLayout.createSequentialGroup()
					.addComponent(labelImageHeight)
					.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
					.addComponent(spinnerImageHeight, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
				)
				.addGroup(zoomLayout.createSequentialGroup()
						.addComponent(labelSamplePoints)
						.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
						.addComponent(spinnerSamplePoints, MIN_SPINNER_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE)
					)
			)
			.addContainerGap()
		);
		
		spinnerPositionX.setToolTipText(TOOLTIP_POSITION_X);
		spinnerPositionY.setToolTipText(TOOLTIP_POSITION_Y);
		spinnerZoomWidth.setToolTipText(TOOLTIP_ZOOM_WIDTH);
		spinnerMaxIterations.setToolTipText(TOOLTIP_MAX_ITERATIONS);
		spinnerImageWidth.setToolTipText(TOOLTIP_IMAGE_WIDTH);
		spinnerImageHeight.setToolTipText(TOOLTIP_IMAGE_HEIGHT);
		spinnerSamplePoints.setToolTipText(TOOLTIP_SAMPLE_POINTS);
		
		// ========== Color Options Layout ==========
		
		colorButtonFractal.setMargin(new Insets(0, MARGIN_BUTTONS, 0, MARGIN_BUTTONS));
		colorButtonRect.setMargin(new Insets(0, MARGIN_BUTTONS, 0, MARGIN_BUTTONS));
		
		tabbedPaneOptions.addTab(TAB_TITLE_COLORS, scrollOptionsColors);
		scrollOptionsColors.setViewportView(panelOptionsColors);
		GroupLayout colorsLayout = new GroupLayout(panelOptionsColors);
		panelOptionsColors.setLayout(colorsLayout);
		
		colorsLayout.setVerticalGroup(colorsLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelColorFractal)
				.addComponent(colorButtonFractal)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(labelColorRect)
				.addComponent(colorButtonRect)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(labelOffset)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addComponent(sliderOffset)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addComponent(gradientPanel)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.BASELINE)
					.addComponent(labelGradientScale)
					.addComponent(spinnerGradientScale)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(labelGradient)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addComponent(gradientChooser)
			.addContainerGap()
		);

		colorsLayout.setHorizontalGroup(colorsLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
				.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.LEADING)
					.addGroup(colorsLayout.createSequentialGroup()
						.addComponent(labelColorFractal)
						.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
						.addComponent(colorButtonFractal)
					)
					.addGroup(colorsLayout.createSequentialGroup()
						.addComponent(labelColorRect)
						.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
						.addComponent(colorButtonRect)
					)
				)
				.addGroup(colorsLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
					.addComponent(labelOffset)
					.addComponent(sliderOffset)
					.addComponent(gradientPanel)
					.addGroup(colorsLayout.createSequentialGroup()
							.addComponent(labelGradientScale)
							.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
							.addComponent(spinnerGradientScale)
					)
					.addComponent(labelGradient)
					.addComponent(gradientChooser)
				)
			)
			.addContainerGap()
		);
	
		colorButtonFractal.setToolTipText(TOOLTIP_FRACTAL_COLOR);
		colorButtonRect.setToolTipText(TOOLTIP_RECT_COLOR);
		sliderOffset.setToolTipText(TOOLTIP_OFFSET);
		spinnerGradientScale.setToolTipText(TOOLTIP_GRAD_SPACING);
		
		// ========== Preset Options Layout ==========
		
		tabbedPaneOptions.addTab(TAB_TITLE_PRESET, scrollOptionsPreset);
		scrollOptionsPreset.setViewportView(panelOptionsPreset);
		GroupLayout presetLayout = new GroupLayout(panelOptionsPreset);
		panelOptionsPreset.setLayout(presetLayout);
		
		presetLayout.setVerticalGroup(presetLayout.createSequentialGroup()
			.addContainerGap()
			.addComponent(labelPresetZoom)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addComponent(comboZoom)
			.addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)
			.addComponent(labelPresetColor)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)
			.addComponent(comboColor)
			.addContainerGap()
		);
			
		presetLayout.setHorizontalGroup(presetLayout.createSequentialGroup()
			.addContainerGap()
			.addGroup(presetLayout.createParallelGroup(GroupLayout.Alignment.CENTER)
				.addComponent(labelPresetZoom)
				.addComponent(comboZoom)
				.addComponent(labelPresetColor)
				.addComponent(comboColor)
			)
			.addContainerGap()
		);
		
		comboZoom.setMaximumRowCount(MandelbrotDiver.zoomPresets.length);
		comboColor.setMaximumRowCount(MandelbrotDiver.colorPresets.length);
		presetLayout.linkSize(SwingConstants.VERTICAL, labelPresetZoom, comboZoom, labelPresetColor, comboColor);
	}
	
	/**
	 * Called by the constructor to add listeners to the GUI components.
	 * The listeners may perform some minor processing (such as checking event types or whether a value has actually changed)
	 * before calling the main method to handle each event.
	 */
	private void initializeListeners() {
		// We want the spinners to check their contents whenever the user clicks elsewhere on the form.
		// Since they automatically check their contents whenever they lose focus,
		// we will simply have the other panels gain focus upon being clicked.
		MouseListener focusGrabber = new MouseAdapter() {
			@Override public void mousePressed(MouseEvent e) {
				((Component)(e.getSource())).requestFocusInWindow();
			}
		};
		imagePanel.addMouseListener(focusGrabber);
		panelOptionsZoom.addMouseListener(focusGrabber);
		panelOptionsColors.addMouseListener(focusGrabber);
		gradientChooser.addMouseListener(focusGrabber);
		getContentPane().addMouseListener(focusGrabber);
		
		imagePanel.addComponentListener(new ComponentAdapter() {
			@Override public void componentResized(ComponentEvent e) {
				updateRectDecoration();
			}
		});
		
		imagePanel.addMouseListener(new MouseAdapter() {
            @Override public void mouseClicked(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e)) {
                	rectDecorator.hide();
                }
            }
            @Override public void mousePressed(MouseEvent e) {
            	if (SwingUtilities.isLeftMouseButton(e)) {
                	startRectangle(e.getX(), e.getY());
                }
            }
            @Override public void mouseReleased(MouseEvent e) {
            	if (SwingUtilities.isLeftMouseButton(e)) {
                	endRectangle(e.getX(), e.getY());
                }
            }
		});
		
		imagePanel.addMouseMotionListener(new MouseMotionAdapter() {
			@Override public void mouseDragged(MouseEvent e) {
				if (SwingUtilities.isLeftMouseButton(e)) {
					dragRectangle(e.getX(), e.getY());
                }
			}
		});
		
		buttonRun.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent e) {
				generate();
			}		
		});
		
		buttonUndo.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent e) {
				undo();
			}		
		});
		buttonRedo.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent e) {
				redo();
			}		
		});
		
		spinnerPositionX.addUserValueChangeListener(new ValueChangeListener<BigDecimal>() {
			@Override public void valueChanged(ValueChangeEvent<BigDecimal> e) {
				if (e.isChanged()) valueChangedPositionX();
			}		
		});
		spinnerPositionY.addUserValueChangeListener(new ValueChangeListener<BigDecimal>() {
			@Override public void valueChanged(ValueChangeEvent<BigDecimal> e) {
				if (e.isChanged()) valueChangedPositionY();
			}		
		});
		spinnerZoomWidth.addUserValueChangeListener(new ValueChangeListener<Double>() {
			@Override public void valueChanged(ValueChangeEvent<Double> e) {
				if (e.isChanged()) valueChangedZoomWidth();
			}		
		});
		spinnerMaxIterations.addUserValueChangeListener(new ValueChangeListener<Long>() {
			@Override public void valueChanged(ValueChangeEvent<Long> e) {
				if (e.isChanged()) valueChangedMaxIterations();
				
			}		
		});
		spinnerImageWidth.addUserValueChangeListener(new ValueChangeListener<Integer>() {
			@Override public void valueChanged(ValueChangeEvent<Integer> e) {
				if (e.isChanged()) valueChangedImageWidth();
			}		
		});
		spinnerImageHeight.addUserValueChangeListener(new ValueChangeListener<Integer>() {
			@Override public void valueChanged(ValueChangeEvent<Integer> e) {
				if (e.isChanged()) valueChangedImageHeight();
			}		
		});
		spinnerSamplePoints.addUserValueChangeListener(new ValueChangeListener<Double>() {
			@Override public void valueChanged(ValueChangeEvent<Double> e) {
				if (e.isChanged()) valueChangedSamplePoints();
			}		
		});
		sliderOffset.addUserValueChangeListener(new ValueChangeListener<Double>() {
			@Override public void valueChanged(ValueChangeEvent<Double> e) {
				if (e.isChanged()) valueChangedOffset();
			}
		});
		spinnerGradientScale.addUserValueChangeListener(new ValueChangeListener<Double>() {
			@Override public void valueChanged(ValueChangeEvent<Double> e) {
				if (e.isChanged()) valueChangedGradientScale();
			}		
		});
		colorButtonFractal.addUserValueChangeListener(new ValueChangeListener<Color>() {	
			@Override public void valueChanged(ValueChangeEvent<Color> e) {
				if (e.isChanged()) valueChangedFractalColor();
			}
		});
		colorButtonRect.addUserValueChangeListener(new ValueChangeListener<Color>() {	
			@Override public void valueChanged(ValueChangeEvent<Color> e) {
				if (e.isChanged()) valueChangedRectColor();
			}
		});
		gradientChooser.addUserValueChangeListener(new ValueChangeListener<Gradient>() {	
			@Override public void valueChanged(ValueChangeEvent<Gradient> e) {
				if (e.isChanged()) valueChangedGradient();
			}
		});
		
		comboZoom.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent e) {
				ZoomPreset preset = MandelbrotDiver.zoomPresets[comboZoom.getSelectedIndex()];
				if (preset != MandelbrotDiver.CHOOSE_ZOOM) zoomPresetSelected(preset);
			}
		});
		comboColor.addActionListener(new ActionListener() {
			@Override public void actionPerformed(ActionEvent e) {
				ColorPreset preset = MandelbrotDiver.colorPresets[comboColor.getSelectedIndex()];
				if (preset != MandelbrotDiver.CHOOSE_COLOR) colorPresetSelected(preset);
			}
		});
		
		// If ctrl+z or ctrl+y is pressed, have the undo or redo methods called, and the key-press event consumed.
		KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatcher() {
			@Override public boolean dispatchKeyEvent(KeyEvent e) {
				if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_Z) {
					if (e.getID() == KeyEvent.KEY_PRESSED) undo();
		        	return true;
				} else if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_Y) {
					if (e.getID() == KeyEvent.KEY_PRESSED) redo();
					return true;
				} else {
					return false;
		       	}
			}
		});
	}

	/**
	 * Called by the constructor to initialize the values displayed in the GUI components.
	 */
	private void initializeValues() {
		OptionState opt = ss.currentOptions();
		spinnerPositionX.setVal(opt.getPositionX());
		spinnerPositionY.setVal(opt.getPositionY());
		spinnerZoomWidth.setVal(opt.getZoomWidth());
		spinnerMaxIterations.setVal(opt.getMaxIterations());
		spinnerImageWidth.setVal(opt.getImageWidth());
		spinnerImageHeight.setVal(opt.getImageHeight());
		spinnerSamplePoints.setVal(opt.getSamplePointsPerPixel());
		sliderOffset.setVal(opt.getOffset());
		spinnerGradientScale.setVal(opt.getGradientScale());
		colorButtonFractal.setColor(opt.getFractalColor());
		colorButtonRect.setColor(opt.getRectColor());
		gradientChooser.setGradient(opt.getGradient());
		gradientPanel.setGradient(opt.getGradient());
		comboZoom.setSelectedItem(MandelbrotDiver.FULL_MAND);
		comboColor.setSelectedItem(MandelbrotDiver.INITIAL_PRESET);
	}

	// ------------------------ Image Generation Methods ---------------------------
	
	/**
	 * Generates escape time data with the current zoom area and options.
	 * Updates the GUI with the new image generated from the data.
	 */
	private void generate() {
		FractalModel model = new MandelbrotModel(ss.currentOptions());
		//long t = System.currentTimeMillis(); // Time operation if desired
		ss.changeRunData(model.escapeTime());
		//long t1 = System.currentTimeMillis() - t;
		updateImage();
		updateRectDecoration();
		updateUndoRedoButtons();
	}
	
	/**
	 * Generates an image based off the current escape time data and color options.
	 * Updates the GUI with the new image.
	 * This method can be called to quickly recolor the image without regenerating the escape time data.
	 */
	private void updateImage() {
		imagePanel.setImage(FractalModel.createImage(ss.currentRunData(), ss.lastRunOptions().getImageWidth(), ss.lastRunOptions().getImageHeight(),
			ss.currentOptions().getGradient(), ss.currentOptions().getFractalColor(), ss.currentOptions().getOffset(), ss.currentOptions().getGradientScale(), LOG_OFFSET));
	}
    
	// ------------------------ Undo / Redo Methods ---------------------------
	
	/**
	 * Undoes a user action if possible and updates GUI accordingly.
	 * This can include changing a particular option or generating a new image.
	 * <p>
	 * The {@link StateStack} tracks only a limited number of changes,
	 * so after a point it will no longer be possible to undo any more actions.
	 */
	private void undo() {
		if (ss.isUndoable()) {
			StateStack.ChangeType change = ss.undo();
			updateUndoRedoButtons();
			updateGUI(change);
		}
	}
	
	/**
	 *  If possible, redoes a user action that has been undone and updates GUI accordingly.
	 */
	private void redo() {
		if (ss.isRedoable()) {
			StateStack.ChangeType change = ss.redo();
			updateUndoRedoButtons();
			updateGUI(change);
		}
	}
	
	/**
	 *  Called after an action is undone or redone to update the GUI.
	 *  
	 *  @param changeType the type of change that has been made.
	 *  This determines which parts of the GUI are updated.
	 */
	private void updateGUI(StateStack.ChangeType changeType) {
		switch (changeType) {
		case RUN_DATA:
			updateImage();
			updateRectDecoration();
			break;
		case POSITION_X:
			spinnerPositionX.setVal(ss.currentOptions().getPositionX());
			updateRectDecoration();
			break;
		case POSITION_Y:
			spinnerPositionY.setVal(ss.currentOptions().getPositionY());
			updateRectDecoration();
			break;
		case ZOOM_WIDTH:
			spinnerZoomWidth.setVal(ss.currentOptions().getZoomWidth());
			updateRectDecoration();
			break;
		case ZOOM_AREA:
			spinnerPositionX.setVal(ss.currentOptions().getPositionX());
			spinnerPositionY.setVal(ss.currentOptions().getPositionY());
			spinnerZoomWidth.setVal(ss.currentOptions().getZoomWidth());
			updateRectDecoration();
			break;
		case MAX_ITERATIONS:
			spinnerMaxIterations.setVal(ss.currentOptions().getMaxIterations());
			break;
		case ZOOM_PRESET:
			spinnerPositionX.setVal(ss.currentOptions().getPositionX());
			spinnerPositionY.setVal(ss.currentOptions().getPositionY());
			spinnerZoomWidth.setVal(ss.currentOptions().getZoomWidth());
			spinnerMaxIterations.setVal(ss.currentOptions().getMaxIterations());
			spinnerGradientScale.setVal(ss.currentOptions().getGradientScale());
			comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
			updateRectDecoration();
			updateImage();
			break;
		case IMAGE_HEIGHT:
			spinnerImageHeight.setVal(ss.currentOptions().getImageHeight());
			updateRectDecoration();
			break;
		case IMAGE_WIDTH:
			spinnerImageWidth.setVal(ss.currentOptions().getImageWidth());
			updateRectDecoration();
			break;
		case SAMPLE_POINTS:
			spinnerSamplePoints.setVal(ss.currentOptions().getSamplePointsPerPixel());
			break;
		case OFFSET:
			sliderOffset.setVal(ss.currentOptions().getOffset());
			updateImage();
			break;
		case GRADIENT_SCALE:
			spinnerGradientScale.setVal(ss.currentOptions().getGradientScale());
			updateImage();
			break;
		case FRACTAL_COLOR:
			colorButtonFractal.setColor(ss.currentOptions().getFractalColor());
			updateImage();
			break;
		case RECT_COLOR:
			colorButtonRect.setColor(ss.currentOptions().getRectColor());
			updateRectDecoration();
			break;
		case GRADIENT:
			gradientChooser.setGradient(ss.currentOptions().getGradient());
			updateGradientPanel();
			updateImage();
			break;
		case COLOR_PRESET:
			colorButtonFractal.setColor(ss.currentOptions().getFractalColor());
			colorButtonRect.setColor(ss.currentOptions().getRectColor());
			gradientChooser.setGradient(ss.currentOptions().getGradient());
			comboColor.setSelectedItem(MandelbrotDiver.CHOOSE_COLOR);
			updateGradientPanel();
			updateRectDecoration();
			updateImage();
			break;
		default:
			break;
		}
	}
	
	/**
	 * Enables or disables the Undo and Redo buttons depending on whether it is currently possible to undo or redo.
	 * This method should be called whenever an Undo or Redo is performed,
	 * and whenever any change is made to the current options.
	 */
	private void updateUndoRedoButtons() {
		buttonUndo.setEnabled(ss.isUndoable());
		buttonRedo.setEnabled(ss.isRedoable());
	}
	
	// ------------------------ Rectangle Click-and-drag Methods ---------------------------
	
	/**
	 * Called when the user presses the mouse down to start drawing a rectangle
	 * @param x the x-value of the pixel where the user clicked down, measured from the top-left of the image
	 * @param y the y-value of the pixel where the user clicked down, measured from the top-left of the image
	 */
    private void startRectangle(int x, int y) {
    	rectDecorator.setRectangle(x, y, 0, 0);
    	rectDecorator.show();
    	rectStartX = x;
    	rectStartY = y;
    }
    
    /**
	 * Called when the user releases the mouse to end drawing a rectangle
	 * @param x the x-value of the pixel where the user released the mouse, measured from the top-left of the image
	 * @param y the y-value of the pixel where the user released the mouse, measured from the top-left of the image
	 */
    private void endRectangle(int x, int y) {
    	// revert to previous rectangle if the ending location is the same as the starting location
    	if (x != rectStartX || y != rectStartY) {
    		int x1 = (x < rectStartX) ? x : rectStartX; // left-most x-pixel
        	int y1 = (y < rectStartY) ? y : rectStartY; // top-most y-pixel
        	int x2 = (x < rectStartX) ? rectStartX : x; // right-most x-pixel
        	int y2 = (y < rectStartY) ? rectStartY : y; // bottom-most y-pixel

        	int imageWidth = ss.currentOptions().getImageWidth();
        	int imageHeight = ss.currentOptions().getImageHeight();
        	
        	double widthVal = widthValue(x2 - x1); // the distance between x1 and x2 in terms of model coordinates
        	double heightVal = heightValue(y2 - y1); // the distance between y1 and y2 in terms of model coordinates
        	
        	// the center of the rectangle in terms of model coordinates
        	BigDecimal centerX;
        	BigDecimal centerY;
        	
        	// the width of the final rectangle in terms of model coordinates
        	// this will be equal to widthVal if the rectangle size is determined by the horizontal distance drawn
        	// the aspect ratio of the rectangle is forced to match the imageWidth : imageHeight ratio
        	// if the rectangle size is determined by the vertical distance drawn, the width may not match widthVal
        	double width = widthVal;
        	
        	// force the aspect ratio to match imageWidth : imageHeight
        	// Note: an extra minus sign is needed when converting between pixel and model y-coordinates
        	// since increasing y is upward in model coordinates and downwards in pixel coordinates
    		if ((x2 - x1) * imageHeight >= (y2 - y1) * imageWidth) {
    			if (y > rectStartY) {
    				centerY = yValue(y1).subtract(new BigDecimal(widthVal / 2 * imageHeight / imageWidth, WIDTH_CONTEXT), ss.currentOptions().mathContext()); 
    			} else {
    				centerY = yValue(y2).add(new BigDecimal(widthVal / 2 * imageHeight / imageWidth, WIDTH_CONTEXT), ss.currentOptions().mathContext()); 
    			}
    			centerX = xValue(x1).add(new BigDecimal(widthVal / 2, WIDTH_CONTEXT), ss.currentOptions().mathContext());
    		} else {
    			if (x > rectStartX) {
    				centerX = xValue(x1).add(new BigDecimal(heightVal / 2 * imageWidth / imageHeight, WIDTH_CONTEXT), ss.currentOptions().mathContext());  
    			} else {
    				centerX = xValue(x2).subtract(new BigDecimal(heightVal / 2 * imageWidth / imageHeight, WIDTH_CONTEXT), ss.currentOptions().mathContext()); 
    			}
    			width = heightVal * imageWidth / imageHeight;
    			centerY = yValue(y2).add(new BigDecimal(heightVal / 2, WIDTH_CONTEXT), ss.currentOptions().mathContext());
    		}
    		
	    	setZoomArea(centerX, centerY, width);
	    }
  
    	updateRectDecoration();
    }
    
    /**
	 * Called when the user drags the mouse while drawing a rectangle
	 * @param x the x-value of the pixel where the mouse is, measured from the top-left of the image
	 * @param y the y-value of the pixel where the mouse is, measured from the top-left of the image
	 */
	private void dragRectangle(int x, int y) {
		int x1 = (x < rectStartX) ? x : rectStartX; // left-most x-pixel
    	int y1 = (y < rectStartY) ? y : rectStartY; // top-most y-pixel
    	int x2 = (x < rectStartX) ? rectStartX : x; // right-most x-pixel
    	int y2 = (y < rectStartY) ? rectStartY : y; // bottom-most y-pixel

    	int imageWidth = ss.currentOptions().getImageWidth();
    	int imageHeight = ss.currentOptions().getImageHeight();
    	
    	// force the aspect ratio to match imageWidth : imageHeight
		if ((x2 - x1) * imageHeight >= (y2 - y1) * imageWidth) {
			if (y > rectStartY) {
				y2 = y1 + (x2 - x1) * imageHeight / imageWidth; 
			} else {
				y1 = y2 - (x2 - x1) * imageHeight / imageWidth;
			}
		} else {
			if (x > rectStartX) {
				x2 = x1 + (y2 - y1) * imageWidth / imageHeight; 
			} else {
				x1 = x2 - (y2 - y1) * imageWidth / imageHeight;
			}
		}

    	rectDecorator.setRectangle(x1, y1, x2 - x1, y2 - y1);
    }
    
	/**
	 * Updates the rectangle to match the current zoom coordinates and selected color
	 */
    private void updateRectDecoration() {
    	rectDecorator.setColor(colorButtonRect.getColor());
    	
    	// Note: an extra minus sign is needed when converting between pixel and model y-coordinates
    	// since increasing y is upward in model coordinates and downwards in pixel coordinates
		int x1 = xPixel(ss.currentOptions().getPositionX().subtract(new BigDecimal(ss.currentOptions().getZoomWidth() / 2, WIDTH_CONTEXT)));
    	int x2 = xPixel(ss.currentOptions().getPositionX().add(new BigDecimal(ss.currentOptions().getZoomWidth() / 2, WIDTH_CONTEXT)));
    	int y1 = yPixel(ss.currentOptions().getPositionY().add(new BigDecimal(ss.currentOptions().zoomHeight() / 2, WIDTH_CONTEXT)));
    	int y2 = yPixel(ss.currentOptions().getPositionY().subtract(new BigDecimal(ss.currentOptions().zoomHeight() / 2, WIDTH_CONTEXT)));
    	rectDecorator.setRectangle(x1, y1, x2 - x1, y2 - y1);
    	
    	// hide if the rectangle exactly matches the image bounds
    	// It is required to check both imageWidth and imageWidth - 1 due to rounding (and similarly for imageHeight)
    	if (x1 == 0 && y1 == 0 && (x2 == imagePanel.displayedImageWidth() || x2 == imagePanel.displayedImageWidth() - 1) && (y2 == imagePanel.displayedImageHeight() || y2 == imagePanel.displayedImageHeight() - 1)) {
    		rectDecorator.hide();
    	} else {
    		rectDecorator.show();
    	}
    }
    
    /**
     * Returns a {@link MathContext} object specifying the desired rounding behavior for {@link BigDecimal} operations
     * as determined by the current zoom level
     * @param width the current zoom level
     * @return {@code MathContext} object specifying the desired rounding behavior for {@code BigDecimal} operations
     */
    public static final MathContext contextFromWidth(double width) {
    	int scale = -((int) Math.floor(Math.log10(width)));
    	return new MathContext(Math.max(16, scale + 16), RoundingMode.HALF_EVEN);
    }
    
    /**
     * Returns the model-coordinate value corresponding to the center of a specific pixel 
     * @param xPixel the x-value of a pixel
     * @return the x-value of the center of the pixel in model coordinates
     */
    private BigDecimal xValue(int xPixel) {
    	return ss.lastRunOptions().getPositionX().add(new BigDecimal(((xPixel + .5) / imagePanel.displayedImageWidth() - .5) * ss.lastRunOptions().getZoomWidth(), WIDTH_CONTEXT), ss.lastRunOptions().mathContext());
    }
    
    /**
     * Returns the model-coordinate value corresponding to the center of a specific pixel 
     * @param yPixel the y-value of a pixel
     * @return the y-value of the center of the pixel in model coordinates
     */
    private BigDecimal yValue(int yPixel) {
    	// Note: an extra minus sign is needed when converting between pixel and model y-coordinates
    	// since increasing y is upward in model coordinates and downwards in pixel coordinates
    	return ss.lastRunOptions().getPositionY().subtract(new BigDecimal(((yPixel + .5) / imagePanel.displayedImageHeight() - .5) * ss.lastRunOptions().zoomHeight(), WIDTH_CONTEXT), ss.lastRunOptions().mathContext());
    }
    
    /**
     * Returns the model-coordinate value of a specific pixel difference
     * @param pixelDifference the width difference in pixels
     * @return the width difference between pixel centers in model coordinates
     */
    private double widthValue(int pixelDifference) {
    	return pixelDifference * ss.lastRunOptions().getZoomWidth() / imagePanel.displayedImageWidth();
    }
    
    /**
     * Returns the model-coordinate value of a specific pixel difference
     * @param pixelDifference the height difference in pixels
     * @return the height difference between pixel centers in model coordinates
     */
    private double heightValue(int pixelDifference) {
    	return pixelDifference * ss.lastRunOptions().zoomHeight() / imagePanel.displayedImageHeight();
    }
    
    /**
     * Returns the pixel corresponding to a specific point in model coordinates
     * @param xValue an x-value in model coordinates
     * @return the x-value of the corresponding pixel
     */
    private int xPixel(BigDecimal xValue) {
    	return (int) ((xValue.subtract(ss.lastRunOptions().getPositionX(), ss.lastRunOptions().mathContext()).doubleValue() / ss.lastRunOptions().getZoomWidth() + .5) * imagePanel.displayedImageWidth());
    }
    
    /**
     * Returns the pixel corresponding to a specific point in model coordinates
     * @param yValue a y-value in model coordinates
     * @return the y-value of the corresponding pixel
     */
    private int yPixel(BigDecimal yValue) {
    	// Note: an extra minus sign is needed when converting between pixel and model y-coordinates
    	// since increasing y is upward in model coordinates and downwards in pixel coordinates
		return (int) ((ss.lastRunOptions().getPositionY().subtract(yValue, ss.lastRunOptions().mathContext()).doubleValue() / ss.lastRunOptions().zoomHeight() + .5) * imagePanel.displayedImageHeight());
    }
    
    /**
     * Sets the zoom area and updates GUI accordingly
     * @param positionX the x-coordinate of the center of the image in model coordinates
     * @param positionY the y-coordinate of the center of the image in model coordinates
     * @param width the width of the image in model coordinates
     */
    private void setZoomArea(BigDecimal positionX, BigDecimal positionY, double width) {
		ss.changeZoomArea(positionX, positionY, width);
		updateUndoRedoButtons();
		spinnerPositionX.setVal(positionX);
		spinnerPositionY.setVal(positionY);
		spinnerZoomWidth.setVal(width);
		comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
	}

    // ------------------------ Value Changed Methods ---------------------------
    
	/**
	 * Updates the {@link GradientPanel} display on the Color tab to display the current gradient.
	 */
	private void updateGradientPanel() {
		gradientPanel.setGradient(ss.currentOptions().getGradient());
	}
    
	/**
	 * Called when the user changes the value of {@code spinnerPositionX}
	 */
    private void valueChangedPositionX() {
    	ss.changePositionX(spinnerPositionX.getVal());
    	updateUndoRedoButtons();
    	updateRectDecoration();
    	comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
    }
    
    /**
	 * Called when the user changes the value of {@code spinnerPositionY}
	 */
    private void valueChangedPositionY() {
    	ss.changePositionY(spinnerPositionY.getVal());
    	updateUndoRedoButtons();
    	updateRectDecoration();
    	comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
    }
    
    /**
	 * Called when the user changes the value of {@code spinnerZoomWidth}
	 */
    private void valueChangedZoomWidth() {
    	ss.changeZoomWidth(spinnerZoomWidth.getVal());
    	updateUndoRedoButtons();
    	updateRectDecoration();
    	comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
    }
    
    /**
	 * Called when the user changes the value of {@code spinnerMaxIterations}
	 */
    private void valueChangedMaxIterations() {
    	ss.changeMaxIterations(spinnerMaxIterations.getVal());
    	updateUndoRedoButtons();
    	comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
    }
    
    /**
	 * Called when the user changes the value of {@code spinnerImageWidth}
	 */
    private void valueChangedImageWidth() {
    	ss.changeImageWidth(spinnerImageWidth.getVal());
    	updateRectDecoration();
    	updateUndoRedoButtons();
    }
    
    /**
	 * Called when the user changes the value of {@code spinnerImageHeight}
	 */
    private void valueChangedImageHeight() {
    	ss.changeImageHeight(spinnerImageHeight.getVal());
    	updateRectDecoration();
    	updateUndoRedoButtons();
    }
    
    /**
	 * Called when the user changes the value of {@code colorButtonFractal}
	 */
    private void valueChangedFractalColor() {
		ss.changeFractalColor(colorButtonFractal.getColor());
		updateImage();
		updateUndoRedoButtons();
		comboColor.setSelectedItem(MandelbrotDiver.CHOOSE_COLOR);
	}

    /**
	 * Called when the user changes the value of {@code colorButtonRect}
	 */
    private void valueChangedRectColor() {
    	ss.changeRectColor(colorButtonRect.getColor());
    	updateRectDecoration();
    	updateUndoRedoButtons();
    	comboColor.setSelectedItem(MandelbrotDiver.CHOOSE_COLOR);
	}

    /**
	 * Called when the user changes the gradient in {@code gradientChooser}
	 */
    private void valueChangedGradient() {
    	ss.changeGradient(gradientChooser.getGradient());
    	updateGradientPanel();
    	updateImage();
    	updateUndoRedoButtons();
    	comboColor.setSelectedItem(MandelbrotDiver.CHOOSE_COLOR);
	}

    /**
   	 * Called when the user changes the value of {@code spinnerSamplePoints}
   	 */
	private void valueChangedSamplePoints() {
		ss.changeSamplePoints(spinnerSamplePoints.getVal());
		updateUndoRedoButtons();
	}

	/**
	 * Called when the user changes the value of {@code sliderOffset}
	 */
	private void valueChangedOffset() {
		ss.changeOffset(sliderOffset.getVal());
		updateImage();
		updateUndoRedoButtons();
	}
 
	/**
   	 * Called when the user changes the value of {@code spinnerGradientScale}
   	 */
	private void valueChangedGradientScale() {
		ss.changeGradientScale(spinnerGradientScale.getVal());
		updateImage();
		updateUndoRedoButtons();
		comboZoom.setSelectedItem(MandelbrotDiver.CHOOSE_ZOOM);
	}
	
	/**
   	 * Called when the user selects a value of {@code comboZoom} not equal to {@link #CHOOSE_ZOOM}
   	 * @param preset the selected preset
   	 */
	private void zoomPresetSelected(ZoomPreset preset) {
		ss.changeZoomPreset(preset);
		spinnerPositionX.setVal(preset.positionX);
		spinnerPositionY.setVal(preset.positionY);
		spinnerZoomWidth.setVal(preset.zoomWidth);
		spinnerMaxIterations.setVal(preset.maxIterations);
		spinnerGradientScale.setVal(preset.gradientScale);
		generate();
	}
	
	/**
   	 * Called when the user selects a value of {@code comboColor} not equal to {@link #CHOOSE_COLOR}
   	 * @param preset the selected preset
   	 */
	private void colorPresetSelected(ColorPreset preset) {
		ss.changeColorPreset(preset);
		colorButtonFractal.setColor(preset.fractalColor);
		colorButtonRect.setColor(preset.rectColor);
    	gradientChooser.setGradient(preset.gradient);
    	updateRectDecoration();
    	updateGradientPanel();
		updateImage();
		updateUndoRedoButtons();
	}
	
	// ------------------------ Misc ---------------------------
    
	/**
	 * @return the set of default options for the program
	 */
	private static OptionState defaultOptions() {
		ZoomPreset zp = FULL_MAND;
		ColorPreset cp = INITIAL_PRESET;
		return new OptionState(zp.positionX, zp.positionY, zp.zoomWidth, zp.maxIterations, 400, 400, 2., 0., zp.gradientScale, cp.fractalColor, cp.rectColor, cp.gradient);
	}

}
